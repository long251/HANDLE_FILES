1. file department.entity
-------------------------
import { Entity, Column, PrimaryGeneratedColumn, OneToMany } from 'typeorm';
import { Account } from './account.entity';

@Entity()
export class Department {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ type: 'varchar', length: 50, unique: true })
  name: string;

  @Column({ type: 'int', unsigned: true, nullable: true })
  total_member: number;

  @Column({ type: 'enum', enum: ['Dev', 'Test', 'ScrumMaster', 'PM'] })
  type: 'Dev' | 'Test' | 'ScrumMaster' | 'PM';

  @Column({ type: 'datetime', default: () => 'CURRENT_TIMESTAMP' })
  created_date: Date;

  @OneToMany(() => Account, (account) => account.department)
  accounts: Account[];
}
==============================================================================================================
2. account entity
-----------------
import { Entity, Column, PrimaryGeneratedColumn, ManyToOne, JoinColumn } from 'typeorm';
import { Department } from './department.entity';

@Entity()
export class Account {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ unique: true, length: 50 })
  username: string;

  @ManyToOne(() => Department, (department) => department.accounts, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'department_id' })
  department: Department;

  @Column({ type: 'enum', enum: ['Male', 'Female', 'LGBT'] })
  gender: string;

  @Column({ type: 'datetime', default: () => 'CURRENT_TIMESTAMP' })
  created_date: Date;
}
============================================================================================================
3, department service:
import { Injectable, NotFoundException, ConflictException, BadRequestException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Department } from 'src/entities/department.entity';
import { Repository } from 'typeorm';
import { Account } from 'src/entities/account.entity';

@Injectable()
export class DepartmentService {
  constructor(
    @InjectRepository(Department)
    private readonly departmentRepository: Repository<Department>,
    @InjectRepository(Account)
    private readonly accountRepository: Repository<Account>,
  ) {}

  // L·∫•y t·∫•t c·∫£ ph√≤ng ban
  async getAllDepartments(): Promise<Department[]> {
    return this.departmentRepository.find();
  }

  // L·∫•y chi ti·∫øt ph√≤ng ban
  async getDepartmentById(id: number): Promise<Department> {
    const department = await this.departmentRepository.findOne({ where: { id } });
    if (!department) {
      throw new NotFoundException('Kh√¥ng t√¨m th·∫•y ph√≤ng ban!');
    }
    return department;
  }

  // T·∫°o m·ªõi ph√≤ng ban
  async createDepartment(departmentData: Partial<Department>): Promise<Department> {
    const newDepartment = this.departmentRepository.create(departmentData);
    return this.departmentRepository.save(newDepartment);
  }

  // C·∫≠p nh·∫≠t ph√≤ng ban
  async updateDepartment(id: number, updateData: Partial<Department>): Promise<Department> {
    const department = await this.getDepartmentById(id);
    if (!department) {
      throw new NotFoundException('Kh√¥ng t√¨m th·∫•y ph√≤ng ban!');
    }
    await this.departmentRepository.update(id, updateData);
    return this.getDepartmentById(id);
  }

  async deleteDepartment(id: number): Promise<void> {
    // Ki·ªÉm tra xem ph√≤ng ban c√≥ t·ªìn t·∫°i kh√¥ng
    const department = await this.getDepartmentById(id);
    if (!department) {
      throw new NotFoundException('Kh√¥ng t√¨m th·∫•y ph√≤ng ban!');
    }
  
    // Ki·ªÉm tra xem c√≥ nh√¢n vi√™n n√†o thu·ªôc ph√≤ng ban kh√¥ng
    const count = await this.accountRepository.count({ where: { department: { id } } });
    if (count > 0) {
      throw new ConflictException('Kh√¥ng th·ªÉ x√≥a ph√≤ng ban v√¨ v·∫´n c√≤n nh√¢n vi√™n!');
    }
  
    // X√≥a ph√≤ng ban
    await this.departmentRepository.delete(id);
  }
  

  //x√≥a nhi·ªÅu
  async deleteMultipleDepartments(ids: number[]): Promise<void> {
    if (!ids.length) {
        throw new BadRequestException('Danh s√°ch ID kh√¥ng h·ª£p l·ªá!');
    }

    // Ki·ªÉm tra t·ª´ng ph√≤ng ban xem c√≥ nh√¢n vi√™n kh√¥ng
    for (const id of ids) {
        const count = await this.accountRepository.count({ where: { department: { id } } });
        if (count > 0) {
            throw new ConflictException(`Kh√¥ng th·ªÉ x√≥a ph√≤ng ban ${id} v√¨ v·∫´n c√≤n nh√¢n vi√™n!`);
        }
    }

    // X√≥a t·∫•t c·∫£ ph√≤ng ban h·ª£p l·ªá
    await this.departmentRepository.delete(ids);
}

}
======================================================================================================
4. controller department:
import { Controller, Get, Post, Put, Delete, Param, Body, NotFoundException } from '@nestjs/common';
import { DepartmentService } from './department.service';
import { Department } from 'src/entities/department.entity';

@Controller('departments')
export class DepartmentController {
  constructor(private readonly departmentService: DepartmentService) {}

  // L·∫•y danh s√°ch ph√≤ng ban
  @Get()
  async getAllDepartments(): Promise<Department[]> {
    return this.departmentService.getAllDepartments();
  }

  // L·∫•y chi ti·∫øt ph√≤ng ban
  @Get(':id')
  async getDepartmentById(@Param('id') id: number): Promise<Department> {
    const department = await this.departmentService.getDepartmentById(id);
    if (!department) {
      throw new NotFoundException('Kh√¥ng t√¨m th·∫•y ph√≤ng ban!');
    }
    return department;
  }

  // T·∫°o ph√≤ng ban m·ªõi
  @Post()
  async createDepartment(@Body() departmentData: Partial<Department>): Promise<Department> {
    return this.departmentService.createDepartment(departmentData);
  }

  // C·∫≠p nh·∫≠t ph√≤ng ban
  @Put(':id')
  async updateDepartment(@Param('id') id: number, @Body() updateData: Partial<Department>): Promise<Department> {
    return this.departmentService.updateDepartment(id, updateData);
  }

  // X√≥a ph√≤ng ban (ch·ªâ khi kh√¥ng c√≥ nh√¢n vi√™n)
  @Delete(':id')
  async deleteDepartment(@Param('id') id: number): Promise<{ message: string }> {
    await this.departmentService.deleteDepartment(id);
    return { message: 'X√≥a ph√≤ng ban th√†nh c√¥ng!' };
  }

  //x√≥a nhi·ªÅu 
  @Delete()
  async deleteMultipleDepartments(@Body('ids') ids: number[]): Promise<{ message: string }> {
    await this.departmentService.deleteMultipleDepartments(ids);
    return { message: 'X√≥a ph√≤ng ban th√†nh c√¥ng!' };
  }
}
==========================================================================================================
5. file Home.tsx (NestUI):
import React, { useState, useEffect } from 'react';
import axios from 'axios';

const API_URL = 'http://localhost:3000/departments';

const Home = () => {
  const [departments, setDepartments] = useState([]);
  const [form, setForm] = useState({ id: null, name: '', total_member: 0, type: '' });

  // üìå Fetch danh s√°ch department
  useEffect(() => {
    fetchDepartments();
  }, []);

  const fetchDepartments = async () => {
    try {
      const res = await axios.get(API_URL);
      setDepartments(res.data);
    } catch (error) {
      console.error('Error fetching departments:', error);
    }
  };

  // üìå Th√™m m·ªõi / C·∫≠p nh·∫≠t department
  const handleSubmit = async (e: any) => {
    e.preventDefault();
    try {
      if (form.id) {
        await axios.put(`${API_URL}/${form.id}`, form);
      } else {
        await axios.post(API_URL, form);
      }
      setForm({ id: null, name: '', total_member: 0, type: '' }); // Reset form
      fetchDepartments(); // Reload danh s√°ch
    } catch (error) {
      console.error('Error saving department:', error);
    }
  };

  // üìå X√≥a department
  const handleDelete = async (id: number) => {
    if (!window.confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a?')) return;
    try {
      await axios.delete(`${API_URL}/${id}`);
      fetchDepartments();
    } catch (error) {
      console.error('Error deleting department:', error);
    }
  };

  // üìå L·∫•y th√¥ng tin chi ti·∫øt ƒë·ªÉ s·ª≠a
  const handleEdit = (department: any) => {
    setForm(department);
  };

  return (
    <div className=''>
      <h2>Department List</h2>

      {/* Form Th√™m / S·ª≠a */}
      <form onSubmit={handleSubmit}>
        <input type="text" placeholder="Name" value={form.name} onChange={(e) => setForm({ ...form, name: e.target.value })} required />
        <input type="number" placeholder="Total Member" value={form.total_member} onChange={(e) => setForm({ ...form, total_member: Number(e.target.value) })} required />
        <input type="text" placeholder="Type" value={form.type} onChange={(e) => setForm({ ...form, type: e.target.value })} required />
        <button type="submit">{form.id ? 'Update' : 'Create'}</button>
      </form>

      {/* Danh s√°ch Departments */}
      <table style={{ width: '100%' , borderCollapse: 'collapse' , padding: '10px'}}>
        <thead style={{border: '1px solid black',padding: '10px'}}>
          <tr style={{border: '1px solid black'}}>
            <th>ID</th>
            <th>Name</th>
            <th>Total Member</th>
            <th>Type</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody style={{border: '1px solid black'}}>
          {departments.map((dep: any) => (
            <tr key={dep.id} style={{border: '1px solid black'}}>
              <td>{dep.id}</td>
              <td>{dep.name}</td>
              <td>{dep.total_member}</td>
              <td>{dep.type}</td>
              <td>
                <button onClick={() => handleEdit(dep)}>Edit</button>
                <button onClick={() => handleDelete(dep.id)}>Delete</button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
};

export default Home;
